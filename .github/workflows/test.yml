name: Test

on:
    push:
        branches: [main]
    pull_request:
        types: [opened, edited, synchronize]

permissions:
    deployments: read
    contents: read

jobs:
    test:
        name: Test
        runs-on: ubuntu-latest
        timeout-minutes: 10

        concurrency:
            group: ${{github.workflow}}-${{ github.head_ref || github.ref_name }}
            cancel-in-progress: true

        env:
            # Get branch name reliably across different trigger events
            BRANCH_NAME: ${{ github.head_ref || github.ref_name }}
            VERCEL_TEAM: team_CAsIwT31pvGxIefovzqpQ824
            VERCEL_PROJECT: prj_JrSPGv0eUF0XpU3ocJYO9m5BfQn7
            VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}

        steps:
            - name: üì• Checkout Code
              uses: actions/checkout@v4

            - name: ü•ü Setup Bun
              uses: oven-sh/setup-bun@v1

            - name: üì¶ Install Dependencies
              run: |
                  bun install --frozen-lockfile
                  bunx playwright install --with-deps chromium

            - name: üîç Pull Environment Variables
              run: |
                  bunx vercel link --yes --scope=steppable --project=vesai --token=$VERCEL_TOKEN
                  if [ "$BRANCH_NAME" = "main" ]; then
                    bunx vercel env pull --yes --environment=production --token=$VERCEL_TOKEN
                  else
                    bunx vercel env pull --yes --environment=preview --git-branch=$BRANCH_NAME --token=$VERCEL_TOKEN
                  fi
                  # Set the branch URL with slashes replaced by hyphens
                  echo "NEXT_PUBLIC_VERCEL_BRANCH_URL=vesai-git-${BRANCH_NAME//\//-}-steppable.vercel.app" >> .env.local

            - name: ‚òÅÔ∏è Await Deployment
              id: vercel-await
              shell: bash
              env:
                  POLL_SECONDS: 10
                  TIMEOUT_SECONDS: 300
              run: |
                  set -euo pipefail

                  # Use the correct commit SHA based on event type
                  if [ "${{ github.event_name }}" = "pull_request" ]; then
                    COMMIT_SHA="${{ github.event.pull_request.head.sha }}"
                  else
                    COMMIT_SHA="${GITHUB_SHA}"
                  fi

                  echo "üîç Awaiting Vercel deployment for '$BRANCH_NAME' (${COMMIT_SHA:0:7})..."

                  # Track time so we can fail after TIMEOUT_SECONDS
                  start_time=$(date +%s)

                  while true; do
                    # Query Vercel Deployments API (v6) using projectId
                    # Get recent deployments for the project
                    resp="$(curl -sS -H "Authorization: Bearer $VERCEL_TOKEN" \
                      "https://api.vercel.com/v6/deployments?teamId=$VERCEL_TEAM&projectId=$VERCEL_PROJECT&limit=20")"

                    # Check if response is valid JSON
                    if ! echo "$resp" | jq -e . >/dev/null 2>&1; then
                      echo "‚ö†Ô∏è  Invalid API response. Re-checking in $POLL_SECONDS s‚Ä¶"
                      sleep "$POLL_SECONDS"
                      continue
                    fi

                    count="$(echo "$resp" | jq -r '.pagination.count // 0')"

                    if [[ "$count" -gt 0 ]]; then
                      
                      # Look for deployment matching our commit SHA
                      # Check multiple fields where the SHA might be stored
                      matching_deployment="$(echo "$resp" | jq -r --arg sha "$COMMIT_SHA" '
                        .deployments[] |
                        select(
                          .meta.githubCommitSha == $sha or
                          .gitSource.sha == $sha or
                          (.meta.githubCommitSha // "" | startswith($sha[0:7]))
                        ) |
                        select(.readyState == "READY") |
                        .url' | head -1)"

                      if [[ -n "$matching_deployment" && "$matching_deployment" != "null" ]]; then
                        echo "‚úÖ Deployment ready: $matching_deployment"
                        break
                      else
                        # Check if there's a building/queued deployment for our SHA
                        building="$(echo "$resp" | jq -r --arg sha "$COMMIT_SHA" '
                          .deployments[] |
                          select(
                            .meta.githubCommitSha == $sha or
                            .gitSource.sha == $sha or
                            (.meta.githubCommitSha // "" | startswith($sha[0:7]))
                          ) |
                          select(.readyState != "READY") |
                          .readyState' | head -1)"
                        
                        if [[ -n "$building" && "$building" != "null" ]]; then
                          echo "üî® Building deployment..."
                        else
                          echo "‚è≥ Waiting for deployment to start..."
                        fi
                      fi
                    else
                      echo "‚è≥ Waiting for deployments..."
                    fi

                    # Timeout guard
                    now=$(date +%s)
                    if (( now - start_time >= TIMEOUT_SECONDS )); then
                      echo "‚ùå Deployment timeout after ${TIMEOUT_SECONDS}s"
                      exit 1
                    fi
                    sleep "$POLL_SECONDS"
                  done

            - name: üß™ Run Tests
              run: |
                  export $(cat .env.local | grep -v '^#' | xargs)
                  bunx playwright test

            - name: üì§ Upload Test Results
              uses: actions/upload-artifact@v4
              if: ${{ !cancelled() }}
              with:
                  name: results
                  path: |
                      playwright-report/
                      test-results/
                  retention-days: 30
